---
title: the expected time of coalescence
layout: post
tags: julia, phylogenetics

---

Normally, writing a function in some programming language to parse a newick
tree is kind of a tedious task, and when you're doning it you wonder why
Felsenstein came up with such a format in thefirst place. Today I found that in
julia, you can simply parse them using simple metaprogramming tools. Moreover,
the `AbstractTrees.jl` library enables to treat trees *really* abstractly.
Check this:

```
julia> using AbstractTree
julia> nw = "((vvi:1.1000000000,((egr:1.0521364740,(ath:0.6820000000,cpa:0.6820000000):0.3701364740):0.0078635260,(mtr:1.000000000,ptr:1.000000000):0.06000000):0.0400000000):0.0702839392,((bvu:0.4330000000,cqu:0.4330000000):0.6820651982,(ugi:0.8350000000,sly:0.8350000000):0.2800651982):0.0552187411);";
julia> ex = Meta.parse(nw)
julia> t = Tree(ex)
:($(Expr(:toplevel, :(((vvi:1.1, ((egr:1.05214, (ath:0.682, cpa:0.682):0.370136):0.00786353, (mtr:1.0, ptr:1.0):0.06):0.04):0.0702839, ((bvu:0.433, cqu:0.433):0.682065, (ugi:0.835, sly:0.835):0.280065):0.0552187)))))
└─ :(((vvi:1.1, ((egr:1.05214, (ath:0.682, cpa:0.682):0.370136):0.00786353, (mtr:1.0, ptr:1.0):0.06):0.04):0.0702839, ((bvu:0.433, cqu:0.433):0.682065, (ugi:0.835, sly:0.835):0.280065):0.0552187))
   ├─ :((vvi:1.1, ((egr:1.05214, (ath:0.682, cpa:0.682):0.370136):0.00786353, (mtr:1.0, ptr:1.0):0.06):0.04):0.0702839)
   │  ├─ :(:)
   │  ├─ :((vvi:1.1, ((egr:1.05214, (ath:0.682, cpa:0.682):0.370136):0.00786353, (mtr:1.0, ptr:1.0):0.06):0.04))
   │  │  ├─ :(vvi:1.1)
   │  │  │  ├─ :(:)
   │  │  │  ├─ :vvi
   │  │  │  └─ 1.1
   │  │  └─ :(((egr:1.05214, (ath:0.682, cpa:0.682):0.370136):0.00786353, (mtr:1.0, ptr:1.0):0.06):0.04)
   │  │     ├─ :(:)
   │  │     ├─ :(((egr:1.05214, (ath:0.682, cpa:0.682):0.370136):0.00786353, (mtr:1.0, ptr:1.0):0.06))
   │  │     │  ├─ :((egr:1.05214, (ath:0.682, cpa:0.682):0.370136):0.00786353)
   │  │     │  │  ├─ :(:)
   │  │     │  │  ├─ :((egr:1.05214, (ath:0.682, cpa:0.682):0.370136))
   │  │     │  │  │  ├─ :(egr:1.05214)
   │  │     │  │  │  │  ├─ :(:)
   │  │     │  │  │  │  ├─ :egr
   │  │     │  │  │  │  └─ 1.05214
   │  │     │  │  │  └─ :((ath:0.682, cpa:0.682):0.370136)
   │  │     │  │  │     ├─ :(:)
   │  │     │  │  │     ├─ :((ath:0.682, cpa:0.682))
   │  │     │  │  │     │  ├─ :(ath:0.682)
   │  │     │  │  │     │  │  ├─ :(:)
   │  │     │  │  │     │  │  ├─ :ath
   │  │     │  │  │     │  │  └─ 0.682
   │  │     │  │  │     │  └─ :(cpa:0.682)
   │  │     │  │  │     │     ├─ :(:)
   │  │     │  │  │     │     ├─ :cpa
   │  │     │  │  │     │     └─ 0.682
   │  │     │  │  │     └─ 0.370136
   │  │     │  │  └─ 0.00786353
   │  │     │  └─ :((mtr:1.0, ptr:1.0):0.06)
   │  │     │     ├─ :(:)
   │  │     │     ├─ :((mtr:1.0, ptr:1.0))
   │  │     │     │  ├─ :(mtr:1.0)
   │  │     │     │  │  ├─ :(:)
   │  │     │     │  │  ├─ :mtr
   │  │     │     │  │  └─ 1.0
   │  │     │     │  └─ :(ptr:1.0)
   │  │     │     │     ├─ :(:)
   │  │     │     │     ├─ :ptr
   │  │     │     │     └─ 1.0
   │  │     │     └─ 0.06
   │  │     └─ 0.04
   │  └─ 0.0702839
   └─ :(((bvu:0.433, cqu:0.433):0.682065, (ugi:0.835, sly:0.835):0.280065):0.0552187)
      ├─ :(:)
      ├─ :(((bvu:0.433, cqu:0.433):0.682065, (ugi:0.835, sly:0.835):0.280065))
      │  ├─ :((bvu:0.433, cqu:0.433):0.682065)
      │  │  ├─ :(:)
      │  │  ├─ :((bvu:0.433, cqu:0.433))
      │  │  │  ├─ :(bvu:0.433)
      │  │  │  │  ├─ :(:)
      │  │  │  │  ├─ :bvu
      │  │  │  │  └─ 0.433
      │  │  │  └─ :(cqu:0.433)
      │  │  │     ├─ :(:)
      │  │  │     ├─ :cqu
      │  │  │     └─ 0.433
      │  │  └─ 0.682065
      │  └─ :((ugi:0.835, sly:0.835):0.280065)
      │     ├─ :(:)
      │     ├─ :((ugi:0.835, sly:0.835))
      │     │  ├─ :(ugi:0.835)
      │     │  │  ├─ :(:)
      │     │  │  ├─ :ugi
      │     │  │  └─ 0.835
      │     │  └─ :(sly:0.835)
      │     │     ├─ :(:)
      │     │     ├─ :sly
      │     │     └─ 0.835
      │     └─ 0.280065
      └─ 0.0552187
```

I found that pretty amazing.  `AbstractTrees` implements tree traversal algorithms 
as well:

```
julia> for l in PostOrderDFS(t); println(l); end
:
:
vvi
1.1
vvi:1.1
:
:
:
egr
1.052136474
egr:1.052136474
:
:
ath
0.682
ath:0.682
:
cpa
0.682
cpa:0.682
(ath:0.682, cpa:0.682)
0.370136474
(ath:0.682, cpa:0.682):0.370136474
(egr:1.052136474, (ath:0.682, cpa:0.682):0.370136474)
0.007863526
(egr:1.052136474, (ath:0.682, cpa:0.682):0.370136474):0.007863526
:
:
mtr
1.0
mtr:1.0
:
ptr
1.0
ptr:1.0
(mtr:1.0, ptr:1.0)
0.06
(mtr:1.0, ptr:1.0):0.06
((egr:1.052136474, (ath:0.682, cpa:0.682):0.370136474):0.007863526, (mtr:1.0, ptr:1.0):0.06)
0.04
((egr:1.052136474, (ath:0.682, cpa:0.682):0.370136474):0.007863526, (mtr:1.0, ptr:1.0):0.06):0.04
(vvi:1.1, ((egr:1.052136474, (ath:0.682, cpa:0.682):0.370136474):0.007863526, (mtr:1.0, ptr:1.0):0.06):0.04)
0.0702839392
(vvi:1.1, ((egr:1.052136474, (ath:0.682, cpa:0.682):0.370136474):0.007863526, (mtr:1.0, ptr:1.0):0.06):0.04):0.0702839392
:
:
:
bvu
0.433
bvu:0.433
:
cqu
0.433
cqu:0.433
(bvu:0.433, cqu:0.433)
0.6820651982
(bvu:0.433, cqu:0.433):0.6820651982
:
:
ugi
0.835
ugi:0.835
:
sly
0.835
sly:0.835
(ugi:0.835, sly:0.835)
0.2800651982
(ugi:0.835, sly:0.835):0.2800651982
((bvu:0.433, cqu:0.433):0.6820651982, (ugi:0.835, sly:0.835):0.2800651982)
0.0552187411
((bvu:0.433, cqu:0.433):0.6820651982, (ugi:0.835, sly:0.835):0.2800651982):0.0552187411
((vvi:1.1, ((egr:1.052136474, (ath:0.682, cpa:0.682):0.370136474):0.007863526, (mtr:1.0, ptr:1.0):0.06):0.04):0.0702839392, ((bvu:0.433, cqu:0.433):0.6820651982, (ugi:0.835, sly:0.835):0.2800651982):0.0552187411)
$(Expr(:toplevel, :(((vvi:1.1, ((egr:1.052136474, (ath:0.682, cpa:0.682):0.370136474):0.007863526, (mtr:1.0, ptr:1.0):0.06):0.04):0.0702839392, ((bvu:0.433, cqu:0.433):0.6820651982, (ugi:0.835, sly:0.835):0.2800651982):0.0552187411))))
```

So OK, this shows it's not yet how we would have programmed a phylogenetic 
tree structure, but it is still neat.




