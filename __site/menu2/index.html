<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
   <link rel="stylesheet" href="/libs/katex/katex.min.css">
     
   <link rel="stylesheet" href="/libs/highlight/github.min.css">
   
  <link rel="stylesheet" href="/css/franklin.css">
  <link rel="stylesheet" href="/css/basic.css">
   <title>Ks distributions with wgd</title>  
</head>
<body>
  <header>
	  <div class="blog-name"><a href="">bb</a></div>
    <nav>
      <ul>
        <li><a href="/">Home</a></li>
        <li><a href="/menu1/">Code blocks</a></li>
        <li><a href="/menu2/">More goodies</a></li>
        <li><a href="/menu3/">Menu 3</a></li>
      </ul>
    </nav>
  </header>

<!-- Content appended here -->

<div class="franklin-content">
<h1 id="computing_k_mathrms_distributions_using_wgd"><a href="#computing_k_mathrms_distributions_using_wgd">Computing \(K_\mathrm{S}\) distributions using <code>wgd</code></a></h1>
<p>Already back in 2017, <a href="https://github.com/arzwa/wgd">I wrote a python library</a> for computing so-called \(K_\mathrm{S}\)<sup id="fnref:ks"><a href="#fndef:ks" class="fnref">[1]</a></sup> distributions. The goal was to provide an easy and robust pipeline to do exactly that, and it seems some people are in fact using it. It is not very actively maintained &#40;and I wish I&#39;d find the time to finish a complete rewrite, register the package and rewrite documentation&#41; but it does the job nicely and efficiently. Here I&#39;ll show how I generally use the library in my research.</p>
<p>First, installation. I have used wgd with Python3.5&#43; &#40;3.5, 3.6, 3.7 and 3.8&#41;. I generally recommend to use a virtual environment for wgd, that way you won&#39;t have dependency issues or clashes. The following should suffice to  install the wgd package in a Ubuntu-ish Linux environment.</p>
<pre><code class="language-bash">sudo apt-get install python3-pip
pip3 install virtualenv --user
virtualenv venv -p python3
source venv/bin/activate
git clone https://github.com/arzwa/wgd.git
cd wgd
pip3 install .</code></pre>
<p>If all went well, you should try running <code>wgd</code>
<pre><code class="language-md">(venv)  $ wgd                                                                                                  
Usage: wgd [OPTIONS] COMMAND [ARGS]...

  Welcome to the wgd command line interface!

                         _______
                         \  ___ `'.
         _     _ .--./)   ' |--.\  \
   /\    \\   ///.''\\    | |    \  '
   `\\  //\\ //| |  | |   | |     |  '
     \`//  \'/  \`-' /    | |     |  |
      \|   |/   /("'`     | |     ' .'
       '        \ '---.   | |___.' /'
                 /'""'.\ /_______.'/
                ||     ||\_______|/
                \'. __//
                 `'---'
  
  wgd  Copyright (C) 2018 Arthur Zwaenepoel
  This program comes with ABSOLUTELY NO WARRANTY;
  This is free software, and you are welcome to redistribute it
  under certain conditions;

  Contact: arzwa@psb.vib-ugent.be

Options:
  -v, --verbosity [info|debug]  Verbosity level, default = info.
  -l, --logfile TEXT            File to write logs to (optional)
  --version                     Print version number
  -h, --help                    Show this message and exit.

Commands:
  dmd  All-vs.-all diamond blastp + MCL clustering.
  kde  Fit a KDE to a Ks distribution.
  ksd  Ks distribution construction.
  mcl  All-vs.-all blastp + MCL clustering.
  mix  Mixture modeling of Ks distributions.
  pre  Check and optionally rename CDS files Example usage (renaming) wgd...
  syn  Co-linearity analyses.
  viz  Plot histograms/densities (interactively).
  wf1  Standard workflow whole paranome Ks.
  wf2  Standard workflow one-vs-one ortholog Ks.</code></pre>
<p>Some third-party tools are required to run the example below. Specifically we will use <code>diamond</code>, <code>mcl</code>, <code>mafft</code>, <code>codeml</code> and <code>fasttree</code>.</p>
<h2 id="the_data"><a href="#the_data">The data</a></h2>
<p>The basic input data is a bunch of CDS sequences. Here I&#39;ll use the CDS data available for the sunfih &#40;<em>Mola mola</em>&#41;. To dowload it from ensembl:</p>
<pre><code class="language-bash">wget ftp://ftp.ensembl.org/pub/release-99/fasta/mola_mola/cds/Mola_mola.ASM169857v1.cds.all.fa.gz
gunzip Mola*gz
mv Mola*fa mola.cds.fasta</code></pre>
<p>There is a little tool in <code>wgd</code> to quickly check the input data. Since \(K_\mathrm{S}\) is a codon-model based evolutionary distance, <em>it is absolutely crucial that the input data are proper codon-sequences</em>. If you&#39;re paranoid about this being  the case, you can use <code>wgd pre</code> to partition a fasta file in everything that is nicely translatable from start to stop codon and all the rest.</p>
<pre><code class="language-julia">wgd pre mola.cds.fasta</code></pre>
<p>This will spit a lot to the screen:</p>
<pre><code class="language-julia">2020-03-01 15:32:20: ERROR	Translation error (First codon 'GAC' is not a start codon) in sequence ENSMMOT00000029500.1
2020-03-01 15:32:20: ERROR	Translation error (First codon 'TGT' is not a start codon) in sequence ENSMMOT00000029501.1
2020-03-01 15:32:20: ERROR	Translation error (First codon 'GCC' is not a start codon) in sequence ENSMMOT00000029502.1
2020-03-01 15:32:20: INFO	20956/29015 (72.22%) sequences are perfect CDS (in mola.cds.fasta.pre.good)
2020-03-01 15:32:20: INFO	8059/29015 (27.78%) sequences are not perfect CDS (in mola.cds.fasta.pre.bad)</code></pre>
<p>About 3/4 of the input data is textbook CDS sequence. The rest has some issue, and is written to the <code>.bad</code> file. Of course, not all CDS sequences start with a start codon, and if you trust your data, you should definitely not throw those away&#33; &#40;you should, however, not trust any sequence with a length that is no multiple of three&#33;&#41;. Here I&#39;ll continue working with the &#39;proper&#39; CDS data, now in the file <code>mola.cds.fasta.pre.good</code>.</p>
<p><strong>Note:</strong> <code>wgd pre</code> can also be used to rename your sequences. If you have the kind of fasta files with very long and awkward headers, I would recommend this, as it will make files obtained later clearer. See the <code>--rename</code> and <code>--prefix</code> options.</p>
<h2 id="obtaining_the_paranome"><a href="#obtaining_the_paranome">Obtaining the paranome</a></h2>
<p>The first step is to obtain the <strong>paranome</strong>, or the collection of all paralogous genes. This is esentially a big graph, where the nodes are all genes in the genome, and edges represent homology &#40;paralogy&#41; relationships. Of course, in the absence of different genomes to compare to, homology is no well-defined concept, as we may as well assume all genes trace back to a common ancestor  and are thus homologous. The goal of paranome inference is of course not to lump everything together, but simply to <em>cluster the genome in reasonably fine-grained  paralogous gene families</em>. Ideally, we&#39;d like to obtain paralogous gene families with a most recent common ancestor &#40;MRCA&#41; that is within the time frame where  \(K_\mathrm{S}\) can be reliably estimated, providing us a clue as to what reasonably  fine-grained could mean.</p>
<p>In general, common gene family clustering methods using Markov graph clustering  &#40;MCL&#41; work well for this task. In wgd an approach based on all-vs.-all protein similarity searches and MCL clustering is implemented. Both <code>blastp</code>, and the  much faster <code>diamond</code> are supported. The following will run <code>diamond</code> &#43; <code>mcl</code> to obtain the paranome:</p>
<pre><code class="language-julia">wgd dmd mola.cds.fasta.pre.good</code></pre>
<p>If one wishes to use the full data &#40;not only the textbook-CDS sequences&#41;, the <code>--nostrictcds</code> and <code>--ignorestop</code> options can be used. Other parameters of interest are the \(e\)-value threshold used to construct the sequence-similarity graph and the inflation factor for MCL, governing the coarseness of the inferred clusters. To see all options for <code>wgd dmd</code> run <code>wgd dmd --help</code>.</p>
<p>If we started from an empty directory, by now we should have obtained the  following &#40;using the non-default <code>tree</code> command in Linux&#41;:</p>
<pre><code class="language-julia">$ tree   
.
├── mola.cds.fasta
├── mola.cds.fasta.pre.bad
├── mola.cds.fasta.pre.good
└── wgd_dmd
    └── mola.cds.fasta.pre.good.mcl</code></pre>
<p>The paranome consists of how many families?</p>
<pre><code class="language-julia">$ wc -l wgd_dmd/mola.cds.fasta.pre.good.mcl
3721 wgd_dmd/mola.cds.fasta.pre.good.mcl</code></pre>
<h2 id="the_k_mathrms_distribution"><a href="#the_k_mathrms_distribution">The \(K_\mathrm{S}\) distribution</a></h2>
<p>To compute the \(K_\mathrm{S}\) distribution, we&#39;ll perform multiple sequence alignment with MAFFT, maximum likelihood estimation of codon substitution model parameters using <code>codeml</code> and do approximate phylogenetic tree inference using FastTree. </p>
<p>Since this takes quite a bit of time &#40;codeml performs a rather expensive  numerical optimization step&#41;, I will take a subset here for illustrative  purposes. I&#39;ll skip a lot of the larger families and take a random sample  of 1000 families from the remaining paralog clusters.</p>
<pre><code class="language-julia">tail -n 2500 wgd_dmd/mola*mcl | shuf | head -n 1000 > wgd_dmd/subset.mcl</code></pre>
<p>If you have the required tools installed, you should be able to run the following:</p>
<pre><code class="language-julia">wgd ksd ./wgd_dmd/subset.mcl ./mola.cds.fasta.pre.good</code></pre>
<p>This will run the analysis in parallel on four CPU cores. It starts with the biggest families &#40;which take more time&#41;. We can monitor the analysis in the  terminal, with output that looks like this.</p>
<pre><code class="language-julia">$  wgd ksd ./wgd_dmd/subset.mcl ./mola.cds.fasta.pre.good  
2020-03-01 16:01:49: INFO	codeml found
2020-03-01 16:01:49: INFO	Translating CDS file
Invalid codon GCN in ENSMMOT00000000017.1            
Invalid codon CNN in ENSMMOT00000000033.1
[...]
100% (20957 of 20957) |#################################################################| Elapsed Time: 0:00:08 Time:  0:00:08
2020-03-01 16:01:57: WARNING	There were 841 warnings during translation
2020-03-01 16:01:57: INFO	Started whole paranome Ks analysis
2020-03-01 16:01:57: WARNING	Filtered out the 0 largest gene families because n*(n-1)/2 > `max_pairwise`
2020-03-01 16:01:57: WARNING	If you want to analyse these large families anyhow, please raise the `max_pairwise` parameter. 
2020-03-01 16:01:57: INFO	Started analysis in parallel (n_threads = 4)
2020-03-01 17:04:01: INFO	Performing analysis on gene family GF_000024
2020-03-01 17:04:01: INFO	Performing analysis on gene family GF_000047
2020-03-01 17:04:01: INFO	Performing analysis on gene family GF_000049
2020-03-01 17:04:01: INFO	Performing analysis on gene family GF_000063
2020-03-01 17:04:08: INFO	Performing analysis on gene family GF_000105
[...]
2020-03-01 17:11:38: INFO	Performing analysis on gene family GF_000999
2020-03-01 17:11:38: INFO	Performing analysis on gene family GF_001000
2020-03-01 17:11:39: INFO	Analysis done
2020-03-01 17:11:39: INFO	Making results data frame
2020-03-01 17:11:49: INFO	Removing tmp directory
2020-03-01 17:11:49: INFO	Computing weights, outlier cut-off at Ks > 5
2020-03-01 17:11:49: INFO	Generating plots
2020-03-01 17:11:49: INFO	Will plot **node-weighted** histograms
2020-03-01 17:11:51: INFO	Done</code></pre>
<p>The generated output is in the <code>wgd_ksd</code> directory</p>
<pre><code class="language-julia">$ tree wgd_ksd
wgd_ksd
├── mola.cds.fasta.pre.good.ks.svg
└── mola.cds.fasta.pre.good.ks.tsv</code></pre>
<p>The main output is the <code>.tsv</code> file, which contains all the results computed in the <code>wgd ksd</code> pipeline:</p>
<pre><code class="language-julia">$ head wgd_ksd/mola.cds.fasta.pre.good.ks.tsv 
	AlignmentCoverage	AlignmentIdentity	AlignmentLength	AlignmentLengthStripped	Distance	Family	Ka	Ks	Node	Omega	Paralog1	Paralog2	WeightOutliersIncluded	WeightOutliersExcluded
ENSMMOT00000011484.1__ENSMMOT00000011486.1	0.998	0.99331	1497.0	1494.0	0.01006	GF_000243	0.0074	0.0042	2.0	1.7654	ENSMMOT00000011484.1	ENSMMOT00000011486.1	1.0	0.0
ENSMMOT00000012497.1__ENSMMOT00000017970.1	0.82812	0.69182	192.0	159.0	0.57805	GF_000294	0.2483	13.3587	2.0	0.0186	ENSMMOT00000012497.1	ENSMMOT00000017970.1	1.0	0.0
ENSMMOT00000012090.1__ENSMMOT00000029246.1	0.05832	0.66049	2778.0	162.0	0.34197	GF_000653	0.1935	57.1628	2.0	0.0034	ENSMMOT00000012090.1	ENSMMOT00000029246.1	1.0	0.0
ENSMMOT00000008583.1__ENSMMOT00000012077.1	0.68619	0.45732	717.0	492.0	1.57304	GF_000429	0.7861	71.4379	2.0	0.011	ENSMMOT00000008583.1	ENSMMOT00000012077.1	1.0	0.0
ENSMMOT00000010608.1__ENSMMOT00000012606.1	0.0681	0.7284	2379.0	162.0	0.44713	GF_000280	0.164	102.0304	4.0	0.0016	ENSMMOT00000010608.1	ENSMMOT00000012606.1	1.0	0.0
ENSMMOT00000012372.1__ENSMMOT00000016766.1	0.78689	0.62553	2379.0	1872.0	0.56786	GF_000280	0.1278	2.2134	5.0	0.0577	ENSMMOT00000016766.1	ENSMMOT00000012372.1	1.0	1.0
ENSMMOT00000010608.1__ENSMMOT00000016766.1	0.81589	0.66358	2379.0	1941.0	0.47837	GF_000280	0.1589	2.0672	6.0	0.0769	ENSMMOT00000010608.1	ENSMMOT00000016766.1	0.25	0.33333
ENSMMOT00000010608.1__ENSMMOT00000012372.1	0.7995	0.61987	2379.0	1902.0	0.58488	GF_000280	0.1103	4.0845	6.0	0.027	ENSMMOT00000010608.1	ENSMMOT00000012372.1	0.25	0.33333
ENSMMOT00000012606.1__ENSMMOT00000016766.1	0.0681	0.68519	2379.0	162.0	0.70868	GF_000280	0.2283	100.4244	6.0	0.0023	ENSMMOT00000012606.1	ENSMMOT00000016766.1	0.25	0.0</code></pre>
<p>The default plot outputted by <code>wgd</code> &#40;in <code>wgd_ksd/*.svg</code>&#41; is rather ugly, but gives a clear overview of the parameter estimates for all gene duplication events, being \(K_\mathrm{S}, K_\mathrm{A}\) and \(\omega\) &#40;i.e. the sysnonymous distance, nonsynonyous distance and nonsynonymous to synonymous substitution rate ratio respectively&#41;.</p>
<p><img src="../assets/mola-wgd.ks.svg" alt="" /></p>
<table class="fndef" id="fndef:ks">
    <tr>
        <td class="fndef-backref"><a href="#fnref:ks">[1]</a></td>
        <td class="fndef-content">Here I&#39;ll use \(K_\mathrm{S}\) and \(K_\mathrm{A}\) instead of the more commonly used \(d\mathrm{S}\) and \(d\mathrm{N}\). This is not due to personal preference &#40;in fact, I would prefer following Ziheng Yang&#39;s notation&#41;, but simply because this is customary in the WGD related literature.</td>
    </tr>
</table>

<div class="page-foot">
  <div class="copyright">
    &copy; Arthur Zwaenepoel. Last modified: March 01, 2020. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>.
  </div>
</div>

</div>
<!-- CONTENT ENDS HERE -->
    
        <script src="/libs/katex/katex.min.js"></script>
<script src="/libs/katex/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>

    
    
        <script src="/libs/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>

    
  </body>
</html>
